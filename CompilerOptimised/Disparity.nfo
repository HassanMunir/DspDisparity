TMS320C6x C/C++ Optimizer               v7.4.6
Build Number 1NKJR-KDADEMDK-RTARQ-WAR-ZAZG_X_U_W

		======File-level Analysis Summary======


static unsigned char GetBestMatch() is called from 2 sites in this file.
    It appears to be inlineable (size = 132 units)
    It has 6 non-trivial scope blocks nested 6 deep.
    It calls these functions:
	rsqrtsp() (1 times)

extern unsigned char *GetDisparityMap() is called from 0 sites in this file.
    It has 4 non-trivial scope blocks nested 4 deep.
    It calls these functions:
	GetBestMatch() (2 times)
	xdc_runtime_Memory_alloc__E() (2 times)


These functions may be recursive:
	GetDisparityMap()
	GetBestMatch()
Inlineable function will be suppressed: GetBestMatch()

These external functions are called but not defined here:
	xdc_runtime_Memory_alloc__E()
	rsqrtsp()


		======= End file-level Analysis =======


==============================================================================

extern unsigned char *GetDisparityMap() is called from 0 sites in this file.
    It has 4 non-trivial scope blocks nested 4 deep.
    It calls these functions:
	GetBestMatch() (2 times)

		====== Unroll-and-jam Result Summary ======

LOOP#1 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#2 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#4 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#5 in GetDisparityMap() fails to unroll-and-jam: Loop nest has a bad shape

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#7 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#8 in GetDisparityMap() fails to unroll-and-jam: Loop nest has a bad shape

		====== End Unroll-and-jam Result ======


ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[1];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[2];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[4];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[5];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[7];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 60
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[8];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[1];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[2];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[4];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[5];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[7];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparityMap[i*width+j] = bestMatchSoFar; at line 64
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[i*width+j];
	and                    disparitiesToSearch[8];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[1];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[2];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[4];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[5];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[7];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j];
	and                    disparitiesToSearch[8];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[0] = disparityMap[(i+1)*width+j]-1; at line 67

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[0];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[1];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[2];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[4];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[5];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[7];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j-1];
	and                    disparitiesToSearch[8];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1; at line 68

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[3];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[6];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[1] = disparitiesToSearch[0]+1; at line 71

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[1];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[2] = disparitiesToSearch[0]+2; at line 72

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[2];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[4] = disparitiesToSearch[3]+1; at line 74

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[4];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[5] = disparitiesToSearch[3]+2; at line 75

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[5];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[7] = disparitiesToSearch[6]+1; at line 77

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[7];
	do not access the same object in memory.

ADVICE: In function GetDisparityMap() in ../Disparity.c
	in the 'for' loop with loop variable 'j' at lines ../Disparity.c:47-79
	for the statement disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1; at line 69
	and the statement disparitiesToSearch[8] = disparitiesToSearch[6]+2; at line 78

	Consider declaring 'disparityMap' as unsigned char * restrict disparityMap
	to assert that lvalues disparityMap[(i+1)*width+j+1];
	and                    disparitiesToSearch[8];
	do not access the same object in memory.

		====== Unroll-and-jam Result Summary ======

LOOP#1 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#2 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#4 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#5 in GetDisparityMap() is unroll-and-jammed by a factor of 2
	old_II = 4   new_II = 4 
	reg_pre_before = 30 reg_pre_after = 0
	inner loop size = 36   outer loop size = 66


		====== End Unroll-and-jam Result ======


		====== Unroll-and-jam Result Summary ======

LOOP#7 in GetDisparityMap() fails to unroll-and-jam: Outer Loop has multiple blocks

		====== End Unroll-and-jam Result ======


Optimization summary for same-iteration parallelism (ILP)
in GetDisparityMap()

  Combining this assignment: disparitiesToSearch[3] = disparityMap[(i+1)*width+j-1]-1;  (line 68)
       with this assignment: disparitiesToSearch[2] = disparitiesToSearch[0]+2;  (line 72)
         giving this result: disparitiesToSearch[2] = PACK(disparitiesToSearch[0]+2, disparityMap[(i+1)*width+j-1]-1);

  Combining this assignment: disparitiesToSearch[6] = disparityMap[(i+1)*width+j+1]-1;  (line 69)
       with this assignment: disparitiesToSearch[5] = disparitiesToSearch[3]+2;  (line 75)
         giving this result: *(NONALIGN(&disparitiesToSearch+20)) = PACK(disparitiesToSearch[3]+2, disparityMap[(i+1)*width+j+1]-1);

  Combining this assignment: disparitiesToSearch[7] = disparitiesToSearch[6]+1;  (line 77)
       with this assignment: disparitiesToSearch[8] = disparitiesToSearch[6]+2;  (line 78)
         giving this result: *(NONALIGN(&disparitiesToSearch+28)) = PACK(disparitiesToSearch[6]+1, disparitiesToSearch[6]+2);


There are 59 memory accesses with 736 dependences.

<<NULL MIX DOMAIN>>

== END OF INFO OUTPUT==
